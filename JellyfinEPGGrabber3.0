#!/usr/bin/python3

# ==========================================
# Schedules Direct to XMLTV - Version 3.0
# Author: mrjacobarussell
# Optimized for: Unraid, Jellyfin, API 20141201
# ==========================================

import requests
import hashlib
import os
import time
import shutil
import random
import json
import xml.etree.ElementTree as ET
from datetime import datetime, timedelta

# --- Configuration ---
USER_NAME = 'user'
PASSWORD = 'password' 
BASE_URL = 'https://json.schedulesdirect.org/20141201'
OUTPUT_DIR = "/mnt/user/appdata/schedulesdirect"
OUTPUT_FILE = f"{OUTPUT_DIR}/guide.xml"
LOGO_DIR = f"{OUTPUT_DIR}/logos"
USER_AGENT = "JellyfinEPGGrabber/3.0 (mrjacobarussell)"

# --- Version 3.0 Toggles ---
DEBUG = True       # Verbose logging
TEST_MODE = False  # Process 1 random channel for debugging
SAVE_JSON = False  # Set to False to disable writing raw .json files to disk

def lprint(text, is_debug=False):
    if is_debug and not DEBUG: return
    prefix = "[DEBUG]" if is_debug else "[INFO]"
    print(f"[{datetime.now().strftime('%H:%M:%S')}] {prefix} {text}", flush=True)

def apply_permissions(path):
    """Recursive chmod 777 and chown nobody:users for Unraid compatibility"""
    lprint(f"Syncing permissions on {path}...", is_debug=True)
    try:
        os.chmod(path, 0o777)
        shutil.chown(path, user="nobody", group="users")
        for root, dirs, files in os.walk(path):
            for d in dirs:
                p = os.path.join(root, d)
                os.chmod(p, 0o777)
                shutil.chown(p, "nobody", "users")
            for f in files:
                p = os.path.join(root, f)
                os.chmod(p, 0o777)
                shutil.chown(p, "nobody", "users")
    except Exception as e:
        lprint(f"Permission Sync Warning: {e}")

def get_token():
    lprint("V3.0 Auth: Requesting Token...", is_debug=True)
    pw_hash = hashlib.sha1(PASSWORD.encode('utf-8')).hexdigest()
    try:
        res = requests.post(f"{BASE_URL}/token", 
                            json={"username": USER_NAME, "password": pw_hash},
                            headers={'User-Agent': USER_AGENT})
        data = res.json()
        return data.get('token') if data.get('code') == 0 else None
    except: return None

def main():
    lprint(f"--- Launching EPG Grabber V3.0 ---")
    if TEST_MODE: lprint("!!! RUNNING IN TEST MODE (1 CHANNEL ONLY) !!!")
    
    os.makedirs(LOGO_DIR, exist_ok=True)
    token = get_token()
    if not token: 
        lprint("Critical Error: Authentication Failed.")
        return
    
    headers = {'token': token, 'User-Agent': USER_AGENT, 'Content-Type': 'application/json'}

    # 1. Lineup & Station Discovery
    lineups_res = requests.get(f"{BASE_URL}/lineups", headers=headers).json()
    master_stations_map = {}
    for entry in lineups_res.get('lineups', []):
        l_id = entry['lineup']
        m_res = requests.get(f"{BASE_URL}/lineups/{l_id}", headers=headers).json()
        map_lookup = {m['stationID']: (f"{m['atscMajor']}.{m['atscMinor']}" if 'atscMajor' in m else m.get('channel')) for m in m_res.get('map', [])}
        for s in m_res.get('stations', []):
            sid = s['stationID']
            s['display_number'] = map_lookup.get(sid, '')
            master_stations_map[sid] = s

    # Test Mode Filter
    station_ids = list(master_stations_map.keys())
    if TEST_MODE and station_ids:
        random_sid = random.choice(station_ids)
        lprint(f"Test Mode Target: {master_stations_map[random_sid].get('callsign')}")
        station_ids = [random_sid]
        master_stations_map = {random_sid: master_stations_map[random_sid]}

    # 2. Schedule Acquisition (Batching 500)
    schedules_raw = []
    lprint(f"Syncing schedules for {len(station_ids)} stations...")
    for i in range(0, len(station_ids), 500):
        batch = [{"stationID": sid} for sid in station_ids[i:i+500]]
        sched_res = requests.post(f"{BASE_URL}/schedules", headers=headers, json=batch)
        if sched_res.status_code == 200:
            schedules_raw.extend(sched_res.json())

    # 3. Metadata Acquisition (Batching 5000, Full 14-char IDs)
    all_prog_ids = list(set(p['programID'] for s in schedules_raw for p in s.get('programs', [])))
    programs_data = {}
    lprint(f"Syncing metadata for {len(all_prog_ids)} unique programs...")
    for i in range(0, len(all_prog_ids), 5000):
        batch = all_prog_ids[i:i+5000]
        prog_res = requests.post(f"{BASE_URL}/programs", headers=headers, json=batch)
        if prog_res.status_code == 200:
            for p in prog_res.json():
                programs_data[p['programID']] = p

    # 4. XMLTV Construction
    lprint("Constructing Version 3.0 XMLTV File...")
    root = ET.Element("tv", {"generator-info-name": "Jellyfin-v3.0-Stable"})
    
    # Process Channels & Icons
    for s_id, s_info in master_stations_map.items():
        ch = ET.SubElement(root, "channel", id=s_id)
        ET.SubElement(ch, "display-name").text = s_info.get('callsign', '')
        if s_info.get('display_number'):
            ET.SubElement(ch, "display-name").text = str(s_info['display_number'])
        
        if 'logo' in s_info:
            local_path = os.path.join(LOGO_DIR, f"{s_id}.png")
            if not os.path.exists(local_path):
                try:
                    img = requests.get(s_info['logo']['URL'], headers={'User-Agent': USER_AGENT}).content
                    with open(local_path, 'wb') as f: f.write(img)
                except: pass
            ET.SubElement(ch, "icon", src=local_path)

    today = datetime.now().date()
    
    # Process Programs
    for s_map in schedules_raw:
        for p in s_map.get('programs', []):
            prog_id = p['programID']
            details = programs_data.get(prog_id, {})
            
            # Timestamp Logic
            start_iso = p['airDateTime'].replace("Z","").split(".")[0]
            start_dt = datetime.strptime(start_iso, "%Y-%m-%dT%H:%M:%S")
            stop_dt = start_dt + timedelta(seconds=p.get('duration', 0))
            
            prog = ET.SubElement(root, "programme", 
                                 start=start_dt.strftime("%Y%m%d%H%M%S +0000"), 
                                 stop=stop_dt.strftime("%Y%m%d%H%M%S +0000"),
                                 channel=s_map['stationID'])
            
            # Advanced New/Repeat Logic
            oad_str = details.get('originalAirDate', '')
            is_new = p.get('new') or oad_str == today.strftime("%Y-%m-%d")
            
            if is_new:
                ET.SubElement(prog, "new")
            else:
                ET.SubElement(prog, "previously-shown", start=oad_str.replace("-",""))

            # Metadata & Series Recording Support
            ET.SubElement(prog, "title").text = details.get('titles', [{}])[0].get('title120', 'No Title')
            
            if prog_id.startswith("SH"):
                # The 'Magic String' for Jellyfin Series DVR support
                ET.SubElement(prog, "episode-num", system="xmltv_ns").text = ". ."
            
            ET.SubElement(prog, "series-id", system="gracenote").text = prog_id[:10]
            
            for g in details.get('genres', []):
                ET.SubElement(prog, "category").text = g

    # 5. Export & Permission Cleanup
    tree = ET.ElementTree(root)
    with open(OUTPUT_FILE, "wb") as f: tree.write(f, encoding='utf-8', xml_declaration=True)
    
    apply_permissions(OUTPUT_DIR)
    lprint(f"--- V3.0 SUCCESS: {OUTPUT_FILE} ---")

if __name__ == "__main__":
    main()
